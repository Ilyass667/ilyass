import tkinter as tk
import time
import threading
from datetime import datetime
from Freenove_DHT import DHT
import RPi.GPIO as GPIO
import firebase_admin
from firebase_admin import credentials, db
import mariadb

# === Initialisation Firebase ===
cred = credentials.Certificate("serviceAccountKey.json")
firebase_admin.initialize_app(cred, {
    'databaseURL': 'https://surveillanceincendie-86824-default-rtdb.firebaseio.com/'
})

# === Configuration MariaDB ===
try:
    mysql_db = mariadb.connect(
        user="root",
        password="root",
        host="localhost",
        database="fire_surveillance"
    )
    mysql_cursor = mysql_db.cursor()
    print("Connexion MariaDB réussie !")
except mariadb.Error as e:
    print(f"Erreur MariaDB: {e}")
    exit()

# === Variables globales ===
temp_value = 15.0
current_humidity = 0.0
door = "Fermé"
mode = "Désactivé"
mode_value = "disabled"
alarm_active = False
test_mode_active = False
manual_alarm_override = False

# === Configuration matérielle ===
DHTPin = 17
dht = DHT(DHTPin)

BUZZER_PIN = 27
LED_PIN = 13
SERVO_PIN = 24
GPIO.setwarnings(False)
GPIO.setmode(GPIO.BCM)
GPIO.setup(BUZZER_PIN, GPIO.OUT)
GPIO.setup(LED_PIN, GPIO.OUT)
GPIO.setup(SERVO_PIN, GPIO.OUT)
GPIO.output(BUZZER_PIN, GPIO.LOW)
GPIO.output(LED_PIN, GPIO.LOW)
servo = GPIO.PWM(SERVO_PIN, 50)
servo.start(0)

def set_servo_angle(angle):
    duty = angle / 18 + 2
    GPIO.output(SERVO_PIN, True)
    servo.ChangeDutyCycle(duty)
    time.sleep(1)
    GPIO.output(SERVO_PIN, False)
    servo.ChangeDutyCycle(0)

def open_door():
    set_servo_angle(90)
    door_status.config(text="État de la trappe : Ouvert")
    print("Trappe ouverte.")

def close_door():
    set_servo_angle(0)
    door_status.config(text="État de la trappe : Fermé")
    print("Trappe fermée.")

def control_alarm():
    global alarm_active
    while True:
        if not manual_alarm_override:
            if temp_value >= 27.0 and not alarm_active:
                GPIO.output(BUZZER_PIN, GPIO.HIGH)
                GPIO.output(LED_PIN, GPIO.HIGH)
                open_door()
                alarm_active = True
                print("Alarme activée ! Température trop élevée.")
            elif temp_value < 27.0 and alarm_active:
                GPIO.output(BUZZER_PIN, GPIO.LOW)
                GPIO.output(LED_PIN, GPIO.LOW)
                close_door()
                alarm_active = False
                print("Alarme désactivée. Température normale.")
        time.sleep(1)

def control_alarm_manual(activate):
    global alarm_active, manual_alarm_override
    manual_alarm_override = activate
    if activate:
        GPIO.output(BUZZER_PIN, GPIO.HIGH)
        GPIO.output(LED_PIN, GPIO.HIGH)
        open_door()
        alarm_active = True
        print("Alarme activée manuellement.")
    else:
        GPIO.output(BUZZER_PIN, GPIO.LOW)
        GPIO.output(LED_PIN, GPIO.LOW)
        close_door()
        alarm_active = False
        print("Alarme désactivée manuellement.")

def change_mode():
    global mode, mode_value, test_mode_active, alarm_active, manual_alarm_override
    if mode == "Désactivé":
        mode = "Activé"
        mode_value = "normal"
        test_mode_active = True
    else:
        mode = "Désactivé"
        mode_value = "disabled"
        test_mode_active = False
        close_door()
        manual_alarm_override = False
        alarm_active = False
    test_mode.config(text=f"Mode test : {mode}")
    plus_btn.configure(state=mode_value)
    minus_btn.configure(state=mode_value)
    open_btn.configure(state=mode_value)
    close_btn.configure(state=mode_value)
    start_btn.configure(state=mode_value)
    end_btn.configure(state=mode_value)

def plus_temp():
    global temp_value
    if test_mode_active:
        temp_value += 1
        update_display()

def minus_temp():
    global temp_value
    if test_mode_active:
        temp_value -= 1
        update_display()

def update_display():
    temp_value_label.config(text=f"{temp_value:.1f} °C   (H: {current_humidity:.1f}%)")


def read_temp_loop():
    def loop():
        global temp_value, current_humidity
        while True:
            if not test_mode_active:
                # Réintroduire la boucle de réessai du capteur
                for _ in range(15):  # <-- Ajouter cette ligne
                    chk = dht.readDHT11()
                    if chk == 0:
                        real_temp = dht.getTemperature()
                        real_humidity = dht.getHumidity()
                        timestamp = datetime.now().isoformat()

                        try:
                            # Insertion MySQL
                            sql = "INSERT INTO sensor_data (temperature, humidity) VALUES (?, ?)"
                            val = (real_temp, real_humidity)
                            mysql_cursor.execute(sql, val)
                            mysql_db.commit()

                            # Envoi à Firebase
                            ref = db.reference('donnees').push({
                                'temperature': real_temp,
                                'humidity': real_humidity,
                                'timestamp': timestamp
                            })
                            
                            # Mise à jour interface
                            temp_value = real_temp
                            current_humidity = real_humidity
                            window.after(0, update_display)
                            print(f"Données sauvegardées (Temp: {real_temp}°C")
                            break  # Sortir de la boucle après succès

                        except Exception as e:
                            print(f"Erreur: {e}")
                            break

                    time.sleep(2)  # Intervalle de réessai réduit
                else:
                    print("Échec lecture capteur après 15 tentatives")
            
            time.sleep(15)  # Intervalle principal inchangé

    threading.Thread(target=loop, daemon=True).start()


def process_commands_loop():
    def loop():
        global test_mode_active
        ref = db.reference('commands')
        while True:
            try:
                cmds = ref.order_by_child('executed').equal_to(False).get() or {}
                for key, cmd in cmds.items():
                    print("Commande reçue:", cmd)
                    
                    if 'mode' in cmd:
                        test_mode_active = (cmd['mode'] == 'test')
                        window.after(0, lambda: test_mode.config(
                            text=f"Mode test : {'Activé' if test_mode_active else 'Désactivé'}"))

                    action = cmd.get('action', '')
                    {
                        'trap_open': open_door,
                        'trap_close': close_door,
                        'buzzer_on': lambda: control_alarm_manual(True),
                        'buzzer_off': lambda: control_alarm_manual(False)
                    }.get(action, lambda: None)()

                    ref.child(key).update({'executed': True})
                    
                time.sleep(5)
            except Exception as e:
                print(f"Erreur commandes: {e}")
                time.sleep(5)
    threading.Thread(target=loop, daemon=True).start()

# === Interface graphique ===
window = tk.Tk()
window.geometry('400x450')

title = tk.Label(window, text="Système de surveillance", font=("Arial",15,"bold"), pady=10)
temp_label = tk.Label(window, text="Température:")
temp_value_label = tk.Label(window, text="0.0", fg="red", font=("Arial",12))
door_status = tk.Label(window, text=f"État de la trappe : {door}", pady=10)
test_mode = tk.Label(window, text=f"Mode test : {mode}", fg="blue", font=("Arial",10,"bold"))
mode_btn = tk.Button(window, text="Basculer mode test", command=change_mode)

frame1 = tk.Frame(window)
plus_btn = tk.Button(frame1, text="+", command=plus_temp, bg="lightgreen", state=tk.DISABLED)
minus_btn = tk.Button(frame1, text="-", command=minus_temp, bg="red", state=tk.DISABLED)

frame2 = tk.Frame(window)
open_btn = tk.Button(frame2, text="Ouvrir", command=open_door, bg="lightgreen", state=tk.DISABLED)
close_btn = tk.Button(frame2, text="Fermer", command=close_door, bg="red", state=tk.DISABLED)

frame3 = tk.Frame(window)
start_btn = tk.Button(frame3, text="Activer", command=lambda: control_alarm_manual(True), bg="lightgreen", state=tk.DISABLED)
end_btn = tk.Button(frame3, text="Arrêter", command=lambda: control_alarm_manual(False), bg="red", state=tk.DISABLED)

# Placement des éléments
title.pack()
temp_label.pack()
temp_value_label.pack()
door_status.pack()
test_mode.pack()
mode_btn.pack(pady=10)

frame1.pack(pady=5)
plus_btn.pack(side=tk.LEFT, padx=5)
minus_btn.pack(side=tk.LEFT)

tk.Label(window, text="Trappe :").pack()
frame2.pack(pady=5)
open_btn.pack(side=tk.LEFT, padx=5)
close_btn.pack(side=tk.LEFT)

tk.Label(window, text="Alarme :").pack()
frame3.pack(pady=5)
start_btn.pack(side=tk.LEFT, padx=5)
end_btn.pack(side=tk.LEFT)

# Démarrage des threads
read_temp_loop()
threading.Thread(target=control_alarm, daemon=True).start()
process_commands_loop()

def on_close():
    print("Nettoyage...")
    mysql_cursor.close()
    mysql_db.close()
    GPIO.output(BUZZER_PIN, GPIO.LOW)
    GPIO.output(LED_PIN, GPIO.LOW)
    close_door()
    servo.stop()
    GPIO.cleanup()
    window.destroy()

window.protocol("WM_DELETE_WINDOW", on_close)
window.mainloop()
