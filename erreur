# Fichier Window.py complet : intégration Firebase et conservation de l’interface Tkinter

import tkinter as tk
import time
import threading
from datetime import datetime                         # Pour timestamp
from Freenove_DHT import DHT                           # Module pour le capteur DHT11 (fichier Freenove_DHT.py dans le même dossier)
import RPi.GPIO as GPIO                                # Bibliothèque pour contrôler les GPIO
import firebase_admin                                  # SDK admin Firebase
from firebase_admin import credentials, db             # Pour l'accès à la Realtime Database

# === Initialisation Firebase ===
cred = credentials.Certificate("serviceAccountKey.json")  
firebase_admin.initialize_app(cred, {
    'databaseURL': 'https://surveillanceincendie-86824-default-rtdb.firebaseio.com/'  # Ton URL Firebase (avec slash final)
})

# === Variables globales ===
temp_value = 15.0          # Température par défaut (pour le mode test)
current_humidity = 0.0     # Humidité mesurée
alarm_active = False       # État de l'alarme automatique
test_mode_active = False   # État du mode Test manuel
manual_alarm_override = False  # Si alarme forcée manuellement

# === Configuration DHT11 ===
DHTPin = 17                # GPIO 17
dht = DHT(DHTPin)

# === Configuration des actionneurs ===
BUZZER_PIN = 27            # GPIO 27
LED_PIN = 13               # GPIO 13
SERVO_PIN = 24             # GPIO 24
GPIO.setmode(GPIO.BCM)
GPIO.setup(BUZZER_PIN, GPIO.OUT)
GPIO.setup(LED_PIN, GPIO.OUT)
GPIO.setup(SERVO_PIN, GPIO.OUT)
GPIO.output(BUZZER_PIN, GPIO.LOW)
GPIO.output(LED_PIN, GPIO.LOW)
servo = GPIO.PWM(SERVO_PIN, 50)  # 50 Hz pour le servo
servo.start(0)

def set_servo_angle(angle):
    """Positionne le servo à l'angle spécifié."""
    duty = angle / 18 + 2
    GPIO.output(SERVO_PIN, True)
    servo.ChangeDutyCycle(duty)
    time.sleep(1)
    GPIO.output(SERVO_PIN, False)
    servo.ChangeDutyCycle(0)

def open_door():
    """Ouvre la trappe."""
    set_servo_angle(90)
    door_status.config(text="État de la trappe : Ouvert")
    print("Trappe ouverte.")

def close_door():
    """Ferme la trappe."""
    set_servo_angle(0)
    door_status.config(text="État de la trappe : Fermé")
    print("Trappe fermée.")

# === Boucle d'alarme automatique ===
def control_alarm():
    global alarm_active
    while True:
        if not manual_alarm_override:
            if temp_value >= 23.0 and not alarm_active:
                GPIO.output(BUZZER_PIN, GPIO.HIGH)
                GPIO.output(LED_PIN, GPIO.HIGH)
                open_door()
                alarm_active = True
                print("Alarme activée ! Température critique.")
            elif temp_value < 23.0 and alarm_active:
                GPIO.output(BUZZER_PIN, GPIO.LOW)
                GPIO.output(LED_PIN, GPIO.LOW)
                close_door()
                alarm_active = False
                print("Alarme désactivée. Température normale.")
        time.sleep(1)

def control_alarm_manual(activate):
    """Active ou désactive l'alarme manuellement."""
    global alarm_active, manual_alarm_override
    manual_alarm_override = activate
    if activate:
        GPIO.output(BUZZER_PIN, GPIO.HIGH)
        GPIO.output(LED_PIN, GPIO.HIGH)
        open_door()
        alarm_active = True
        print("Alarme activée manuellement.")
    else:
        GPIO.output(BUZZER_PIN, GPIO.LOW)
        GPIO.output(LED_PIN, GPIO.LOW)
        close_door()
        alarm_active = False
        print("Alarme désactivée manuellement.")

# === Fonctions UI pour le mode Test ===
def plus_temp():
    global temp_value
    if test_mode_active:
        temp_value += 1
        update_display()

def minus_temp():
    global temp_value
    if test_mode_active:
        temp_value -= 1
        update_display()

def update_display():
    temp_value_label.config(text=f"{temp_value:.1f} °C   (H : {current_humidity:.1f} %)")

def toggle_test_mode():
    """Active ou désactive le mode Test manuel."""
    global test_mode_active
    test_mode_active = not test_mode_active
    state = "Activé" if test_mode_active else "Désactivé"
    test_mode.config(text=f"Mode test : {state}")
    # Activer/désactiver les boutons +/-
    plus_btn.configure(state=tk.NORMAL if test_mode_active else tk.DISABLED)
    minus_btn.configure(state=tk.NORMAL if test_mode_active else tk.DISABLED)

# === Lecture capteur et envoi Firebase ===
def read_temp_loop():
    def loop():
        global temp_value, current_humidity
        while True:
            if not test_mode_active:
                chk = dht.readDHT11()
                if chk == 0:
                    current_humidity = dht.getHumidity()
                    temp_value = dht.getTemperature()
                    timestamp = datetime.now().isoformat()
                    data = {
                        'temperature': temp_value,
                        'humidity': current_humidity,
                        'timestamp': timestamp
                    }
                    try:
                        db.reference('donnees').push(data)
                    except Exception as e:
                        print("Erreur lors de l'envoi Firebase :", e)
                    window.after(0, update_display)
                else:
                    print(f"Erreur lecture DHT11, code : {chk}")
            time.sleep(15)  # Envoi toutes les 15 secondes

    t = threading.Thread(target=loop, daemon=True)
    t.start()

# === Interface Tkinter ===
window = tk.Tk()
window.geometry('400x480')
window.title("Système de surveillance incendie")

title = tk.Label(window, text="Système de surveillance", font=("Arial", 15, "bold"), pady=10)
temp_value_label = tk.Label(window, text="0.0 °C   (H : 0.0 %)", fg="red", font=("Arial", 12))
door_status = tk.Label(window, text="État de la trappe : Fermé", pady=10)
test_mode = tk.Label(window, text="Mode test : Désactivé", fg="blue", pady=10, font=("Arial", 10, "bold"))

# Boutons
mode_btn = tk.Button(window, text="Basculer mode test", command=toggle_test_mode)

frame1 = tk.Frame(window)
plus_btn = tk.Button(frame1, text="+", command=plus_temp, width=3, state=tk.DISABLED)
minus_btn = tk.Button(frame1, text="-", command=minus_temp, width=3, state=tk.DISABLED)

frame2 = tk.Frame(window)
open_btn = tk.Button(frame2, text="Ouvrir trappe", command=open_door)
close_btn = tk.Button(frame2, text="Fermer trappe", command=close_door)

frame3 = tk.Frame(window)
start_btn = tk.Button(frame3, text="Activer alarme", command=lambda: control_alarm_manual(True))
end_btn = tk.Button(frame3, text="Arrêter alarme", command=lambda: control_alarm_manual(False))

# Placement
title.pack(pady=5)
temp_value_label.pack(pady=5)
door_status.pack(pady=5)
test_mode.pack(pady=5)
mode_btn.pack(pady=5)
frame1.pack(pady=5)
plus_btn.pack(side=tk.LEFT, padx=5)
minus_btn.pack(side=tk.LEFT)
frame2.pack(pady=5)
open_btn.pack(side=tk.LEFT, padx=5)
close_btn.pack(side=tk.LEFT)
frame3.pack(pady=5)
start_btn.pack(side=tk.LEFT, padx=5)
end_btn.pack(side=tk.LEFT)

# Démarrage des threads
read_temp_loop()
alarm_thread = threading.Thread(target=control_alarm, daemon=True)
alarm_thread.start()

# Nettoyage GPIO à la fermeture
def on_close():
    GPIO.output(BUZZER_PIN, GPIO.LOW)
    GPIO.output(LED_PIN, GPIO.LOW)
    close_door()
    servo.stop()
    GPIO.cleanup()
    window.destroy()

window.protocol("WM_DELETE_WINDOW", on_close)
window.mainloop()
